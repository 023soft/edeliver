#!/usr/bin/env bash

REQUIRED_CONFIGS+=("APP")
REQUIRED_CONFIGS+=("BUILD_HOST")
REQUIRED_CONFIGS+=("BUILD_USER")
REQUIRED_CONFIGS+=("BUILD_AT")
OPTIONAL_CONFIGS+=("TO")
OPTIONAL_CONFIGS+=("REBAR_CONFIG")

TO="${TO:=$(get_latest_commit)}"

help() {
  echo -e "
${bldwht}Usage:${txtrst}
  edeliver upgrade [Options]

${txtbld}Options:${txtrst}
  --to=<git-tag> The revision to build the upgrade for. Default is the HEAD
             of the master branch or the branch passed as ${bldwht}--branch=${txtrst} argument.
  --branch=<git-branch> The branch to build. ${txtylw}Default is the master branch${txtrst}.
             ${txtgrn}The branch doesn't need to be pushed to remote${txtrst} before building.
             The revision passed as ${bldwht}--from=${txtrst} or ${bldwht}--to=${txtrst} argument must be in
             that branch.
  --mix-env=<env> Build the upgrade with a custom mix environment.
             Default is ${bldwht}prod${txtrst}.
  --restart-crashed ${txtgrn}Restart terminated nodes${txtrst} which crashed
             during hot code upgrade. They will be restarted ${txtgrn}with the
             new version${txtrst}.
  --skip-relup-mod Skip modification of the grenerated relup instructions.
             No custom relup instructions are added.
  --relup-mod=<module-name> The name of the module to modify the relup if there are several modules. The module
             must implement the Behaviour Edeliver.Relup.Modification.
  --auto-version=[patch|minor|major|git] Automatically increases the patch,
             minor or major version of the upgrade or appends the git sha1
             revision to the current version. If any other term is used
             that string is used as the version of the new upgrade.

${txtbld}Faster Builds:${txtrst} ${txtblu}(Faster builds might fail during build or during runtime)${txtrst}
  --skip-git-clean Don't build from a clean state for faster builds. Can be
             adjusted by the ${bldwht}GIT_CLEAN_PATHS${txtrst} environment variable. Should be
             at least ${bldwht}rel${txtrst} for elixir releases.
  --skip-mix-clean Skip the 'mix clean step' for faster builds. Can be used
             in addition to ${bldwht}--skip-git-clean${txtrst} Option for incremental builds.

${bldylw}Info:${txtrst}
  ${txtgrn}Builds an upgrade${txtrst} on the build host based on the current version
  running on the staging (default) or production hosts and
  ${txtylw}deploys the upgrade${txtrst} to all nodes using ${txtgrn}hot code upgrade${txtrst}.
  It performs these single steps:

    * detect current version on all running nodes
    * validate all nodes run the same version
    * build new upgrade to that version (or use existing)
    * patch relup file if necessary (see ${bldwht}build upgrade${txtrst}) command
    * deploy (hot code) upgrade while nodes are running
    * validate that all nodes run the upgraded version
    * deploy the release to not running nodes
  "
}


set_deploy_hosts


run() {
  [[ "$MODE" = "verbose" ]] && local _verbose="--verbose"
  [[ $ARGS =~ "production" ]] && export DEPLOY_ENVIRONMENT="production" || export DEPLOY_ENVIRONMENT="staging"
  # detect revision to install on build host
  local _branch_to_install="$BRANCH" _revision_to_install=$(git rev-parse --short "$BRANCH") _version_to_install=$(grep -rone 'version:\s\+"[^-]\+' mix.exs | cut -d'"' -f2)
  [[ -z "$_branch_to_install" || -z "$_revision_to_install" ]] && error "Failed to detect branch or revision to install."
  status "Upgrading to revision $_revision_to_install from branch $_branch_to_install"
  local _hosts="${HOSTS_APP_USER}" _host
  status "Detecting release versions on $DEPLOY_ENVIRONMENT hosts..."
  local _running_release_version
  local _offline_deploy_hosts=() _online_upgrade_hosts=()
  # detect which deploy hosts are up and the version running on that hosts
  for _host in $_hosts
  do
    __verbose -n "Checking version on host $_host..."
    local _installed_release_version
    _installed_release_version=$(__get_installed_version_on_host $_host)
    if [[ "$?" -ne 0 ]]; then
      __is_node_offline $_host \
        && __verbose -e "\rNode on deploy host $_host is down." && _offline_deploy_hosts+=("$_host") \
        || error "\nDetection of version failed on $_host"
    else # version detection succeeded
      __verbose -e "\rVersion $_installed_release_version is installed on host $_host"
      _online_upgrade_hosts+=("$_host")
      if [[ -z "$_running_release_version" ]]; then
        _running_release_version="$_installed_release_version"
      elif [[ "$_running_release_version" != "$_installed_release_version" ]]; then
        error "Different version $_installed_release_version is running on host $_host.\nExpecting all nodes to run version $_running_release_version.\nPlease upgrade that node first."
      fi
    fi
  done
  # deploy upgrade to online hosts running the same version
  for _host in ${_online_upgrade_hosts}; do
    __verbose "Deploying upgrade to host $_host"
  done

  # deploy clean release to offline hosts and start it
  for _host in ${_offline_deploy_hosts}; do
    __verbose "Deploying release to offline host $_host"
  done
 # steps:

 #  - detect current version on all running nodes
 #    - no node running
 #      - __deploy_release_to_not_running_nodes
 #    - all nodes run the same version
 #      - check if upgrade is already in release store
 #        - __deploy_upgrade_to_running_nodes
 #        - __validate_upgrade_succeeded
 #        - __deploy_release_to_not_running_nodes
 #      - upgrade is not in store
 #        - build upgrade
 #        - __deploy_upgrade_to_running_nodes
 #        - __validate_upgrade_succeeded
 #        - __deploy_release_to_not_running_nodes
 #    - not all nodes run the same version
 #      - abort: must first upgrade nodes to the same version manually
  :
}

__deploy_release_to_not_running_nodes() {
  :
}

__deploy_upgrade_to_running_nodes() {
  :
}

__validate_upgrade_succeeded() {
  :
}

# executes a command given as second argument on the
# deploy host given as first argument by first sourcing
# the ~/.profile and changing into the application directory
__execute_on_deploy_host() {
  local _host="$1"
  local _command="$2"

  ssh -o ConnectTimeout="$SSH_TIMEOUT" "$_host" "
    set -e
    [ -f ~/.profile ] && source ~/.profile
    cd $DELIVER_TO/$APP $SILENCE
    $_command"
}

# prints commands to set the erl command as ERL env on the
# deploy host. must be executed as: \$ERL -boot \$BOOT_FILE -noshell -eval
__get_erl_command_on_deploy_host() {
  cat <<END_OF_SCRIPT
      BOOT_FILE=\$(ls -1 releases/*/start_clean.boot | grep -e '[[:digit:]]' | tail -1)
      BOOT_FILE=\${BOOT_FILE%.*}
      ERL=\$(pwd)/\$(ls -1 | grep erts | tail -1)/bin/erl
END_OF_SCRIPT
}

# checks whether the node on the deploy host passed as first
# argument responds to pings or not. returns 0 if node is online
# and returns 1 if node is offline.
__is_node_offline() {
  local _deploy_host="$1"
  [[ "pong" != "$(__execute_on_deploy_host "$_deploy_host" "bin/$APP ping" | tail -1)" ]]
}

# prints the currently running release version
# on the deploy host passed as first argument.
__get_installed_version_on_host() {
 local _deploy_host="$1"
 __execute_on_deploy_host "$_deploy_host" "
      $(__get_erl_command_on_deploy_host)
      2>&1 bin/$APP rpc release_handler which_releases '[].' | tr -d \"\n\" | grep -o '\[.*' | 2>&1 \$ERL -boot \$BOOT_FILE -noshell -eval '$(__current_release_erl_script)' -run erlang halt"
}

# prints an erlang script which detects the current
# release from the list of installed releases returned
# by the release_handler.which_releases function.
__current_release_erl_script() {
  cat <<END_OF_SCRIPT
  {ok,Tokens,_} = erl_scan:string(io:get_line("") ++ "."),
  {ok,Releases} = erl_parse:parse_term(Tokens),
  SortedReleases = lists:sort(fun({_NameA, _VersionA, _LibNameA, StatusA}, {_NameB, _VersionB, _LibNameB, StatusB}) ->
    if
     StatusA == StatusB -> true;
     StatusA == current -> true;
     StatusA == permanent -> StatusB /= current;
     true -> false
    end
  end, Releases),
  case [{Version, Status} || {_Name, Version, _LibName, Status} <- SortedReleases, Status == current orelse Status == permanent] of
   [{CurrentVersion, current} | _] -> io:format("~s", [CurrentVersion]);
   [{PermanentVersion, permanent}] -> io:format("~s", [PermanentVersion]);
   _ -> halt(1)
  end.
END_OF_SCRIPT
}

# prints verbose output if verbose mode is enabled
__verbose() {
  [[ "$MODE" = "verbose" ]] && echo $@
}
