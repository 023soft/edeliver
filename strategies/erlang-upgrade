#!/usr/bin/env bash

REQUIRED_CONFIGS+=("APP")
REQUIRED_CONFIGS+=("BUILD_HOST")
REQUIRED_CONFIGS+=("BUILD_USER")
REQUIRED_CONFIGS+=("BUILD_AT")
OPTIONAL_CONFIGS+=("TO")
OPTIONAL_CONFIGS+=("REBAR_CONFIG")

TO="${TO:=$(get_latest_commit)}"

help() {
  echo -e "
${bldwht}Usage:${txtrst}
  edeliver upgrade [Options]

${txtbld}Options:${txtrst}
  --to=<git-tag> The revision to build the upgrade for. Default is the HEAD
             of the master branch or the branch passed as ${bldwht}--branch=${txtrst} argument.
  --branch=<git-branch> The branch to build. ${txtylw}Default is the master branch${txtrst}.
             ${txtgrn}The branch doesn't need to be pushed to remote${txtrst} before building.
             The revision passed as ${bldwht}--from=${txtrst} or ${bldwht}--to=${txtrst} argument must be in
             that branch.
  --mix-env=<env> Build the upgrade with a custom mix environment.
             Default is ${bldwht}prod${txtrst}.
  --restart-crashed ${txtgrn}Restart terminated nodes${txtrst} which crashed
             during hot code upgrade. They will be restarted ${txtgrn}with the
             new version${txtrst}.
  --skip-relup-mod Skip modification of the grenerated relup instructions.
             No custom relup instructions are added.
  --relup-mod=<module-name> The name of the module to modify the relup if there are several modules. The module
             must implement the Behaviour Edeliver.Relup.Modification.
  --auto-version=[patch|minor|major|git] Automatically increases the patch,
             minor or major version of the upgrade or appends the git sha1
             revision to the current version. If any other term is used
             that string is used as the version of the new upgrade.

${txtbld}Faster Builds:${txtrst} ${txtblu}(Faster builds might fail during build or during runtime)${txtrst}
  --skip-git-clean Don't build from a clean state for faster builds. Can be
             adjusted by the ${bldwht}GIT_CLEAN_PATHS${txtrst} environment variable. Should be
             at least ${bldwht}rel${txtrst} for elixir releases.
  --skip-mix-clean Skip the 'mix clean step' for faster builds. Can be used
             in addition to ${bldwht}--skip-git-clean${txtrst} Option for incremental builds.

${bldylw}Info:${txtrst}
  ${txtgrn}Builds an upgrade${txtrst} on the build host based on the current version
  running on the staging (default) or production hosts and
  ${txtylw}deploys the upgrade${txtrst} to all nodes using ${txtgrn}hot code upgrade${txtrst}.
  It performs these single steps:

    * detect current version on all running nodes
    * validate all nodes run the same version
    * build new upgrade to that version (or use existing)
    * patch relup file if necessary (see ${bldwht}build upgrade${txtrst}) command
    * deploy (hot code) upgrade while nodes are running
    * validate that all nodes run the upgraded version
    * deploy the release to not running nodes
  "
}


set_deploy_hosts


run() {
  [[ "$MODE" = "verbose" ]] && local _verbose="--verbose"
  [[ $ARGS =~ "production" ]] && export DEPLOY_ENVIRONMENT="production" || export DEPLOY_ENVIRONMENT="staging"
  # detect revision to install on build host
  local _branch_to_install="$BRANCH" _revision_to_install=$(git rev-parse --short "$BRANCH") _version_to_install=$(grep -rone 'version:\s\+"[^-]\+' mix.exs | cut -d'"' -f2)
  [[ -z "$_branch_to_install" || -z "$_revision_to_install" ]] && error "Failed to detect branch or revision to install."
  status "Upgrading to revision $_revision_to_install from branch $_branch_to_install"
  local _hosts="${HOSTS_APP_USER}"
  status "Detecting release versions on $DEPLOY_ENVIRONMENT hosts..."
  local _running_release_version
  for _host in $_hosts
  do
    __verbose -n "Checking version on host $_host..."
    local _installed_release_version
    _installed_release_version=$(__get_installed_version_on_host $_host)
    __verbose -e "\rVersion $_installed_release_version is installed on host $_host"
    if [[ -z "$_running_release_version" ]]; then
      _running_release_version="$_installed_release_version"
    elif [[ "$_running_release_version" != "$_installed_release_version" ]]; then
      error "Different version $_installed_release_version is running on host $_host.\nExpecting all nodes to run version $_running_release_version.\nPlease upgrade that node first."
    fi
  done
 # steps:

 #  - detect current version on all running nodes
 #    - no node running
 #      - __deploy_release_to_not_running_nodes
 #    - all nodes run the same version
 #      - check if upgrade is already in release store
 #        - __deploy_upgrade_to_running_nodes
 #        - __validate_upgrade_succeeded
 #        - __deploy_release_to_not_running_nodes
 #      - upgrade is not in store
 #        - build upgrade
 #        - __deploy_upgrade_to_running_nodes
 #        - __validate_upgrade_succeeded
 #        - __deploy_release_to_not_running_nodes
 #    - not all nodes run the same version
 #      - abort: must first upgrade nodes to the same version manually
  :
}

__deploy_release_to_not_running_nodes() {
  :
}

__deploy_upgrade_to_running_nodes() {
  :
}

__validate_upgrade_succeeded() {
  :
}

__execute_on_deploy_host() {
  local _host="$1"
  local _command="$2"

  ssh -o ConnectTimeout="$SSH_TIMEOUT" "$_host" "
    set -e
    [ -f ~/.profile ] && source ~/.profile
    cd $DELIVER_TO/$APP $SILENCE
    $_command"
}

__get_installed_version_on_host() {
 local _deploy_host="$1"
 __execute_on_deploy_host "$_deploy_host" "
      BOOT_FILE=\"releases/\$(ls -1 releases | grep -m1 -e '[[:digit:]]')/start_clean\"
      ERL=\"\$(ls -1 | grep -m1 erts)/bin/erl\"
      bin/$APP rpc release_handler which_releases '[].' | tr -d \"\n\" | grep -o '\[.*' | \$ERL -boot \$BOOT_FILE -noshell -eval '$(__current_release_erl_script)' -run erlang halt"
}

__current_release_erl_script() {
  cat <<END_OF_SCRIPT
  {ok,Tokens,_} = erl_scan:string(io:get_line("") ++ "."),
  {ok,Releases} = erl_parse:parse_term(Tokens),
  SortedReleases = lists:sort(fun({_NameA, _VersionA, _LibNameA, StatusA}, {_NameB, _VersionB, _LibNameB, StatusB}) ->
    if
     StatusA == StatusB -> true;
     StatusA == current -> true;
     StatusA == permanent -> StatusB /= current;
     true -> false
    end
  end, Releases),
  case [{Version, Status} || {_Name, Version, _LibName, Status} <- SortedReleases, Status == current orelse Status == permanent] of
   [{CurrentVersion, current} | _] -> io:format("~s", [CurrentVersion]);
   [{PermanentVersion, permanent}] -> io:format("~s", [PermanentVersion]);
   _ -> halt(1)
  end.
END_OF_SCRIPT
}

__verbose() {
  [[ "$MODE" = "verbose" ]] && echo $@
}
