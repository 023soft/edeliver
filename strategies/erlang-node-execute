#!/usr/bin/env bash

REQUIRED_CONFIGS+=("APP")
REQUIRED_CONFIGS+=("NODE_ACTION")
REQUIRED_CONFIGS+=("NODE_ENVIRONMENT")


require_node_config


run() {
  [[ "$NODE_ACTION" = version ]] && status "getting release versions from $NODE_ENVIRONMENT servers" || status "${NODE_ACTION}ing $NODE_ENVIRONMENT servers"
  authorize_hosts
  authorize_remote_hosts 
  execute_node_command $NODE_ACTION
}

# executes a node command asynchronously on all
# remote nodes and prints the result for each node.
execute_node_command() {
  local _node_command=$1
  
  echo
  background_jobs_pids=()
  background_jobs_nodes=()
  background_jobs_results=()
  mkdir -p "$LOCAL_RELEASE_STORE/.tmp"

  local i=0; 
  for _node in $NODES;
  do
    __execute_node_command $i "$_node" "$_node_command" &
    background_jobs_pids+=("$!")
    background_jobs_nodes+=("$_node")
    i=$((i+1))

  done
  
  local _had_errors=0
  for (( i = 0 ; i < ${#background_jobs_pids[@]} ; i++ ))
  do
    wait ${background_jobs_pids[$i]}
    __print_node_command_result $i
    [[ "$?" = 0 ]] || _had_errors=1
  done
  return $_had_errors  
}

# executes a node command on a given node.
# the result is written to $LOCAL_RELEASE_STORE/.tmp/node_command_result_$$_${_node_index} 
# in format "StatusCode|Output"
__execute_node_command() {
  local _node_index=$1
  local _node_name=$2
  local _node_command=$3
  
  local _config; local _config_arg
  local _user=${_node_name%@*}
  local _host=${_node#*@}
  local _path=${_host#*:}
  [[ "$_path" =~ .*\|.* ]] && _config=${_path#*|} || _config=""
  _path=${_path%|*}
  _host=${_host%:*}
  
  [[ -n "$_config" ]] && _config_arg="--config=${_config}" || _config_arg=""
  
  _remote_job="
    set -e
    [ -f ~/.profile ] && source ~/.profile
    cd ${_path}/${APP} $SILENCE
    bin/${APP} ${_node_command} ${_config_arg}
  "
  
  node_execute_result=$(ssh -o ConnectTimeout="$SSH_TIMEOUT" "${_user}@${_host}" "$_remote_job")
  local _status_code="$?"
  echo "${_status_code}|${node_execute_result}" > "$LOCAL_RELEASE_STORE/.tmp/node_command_result_$$_${_node_index}"
  # echo "command for node $_node_name and index $_node_index finished with status code $_status_code and result ${node_execute_result} | ${PPID} | $$"
}

# prints the result from the execution of a node command on a remote node.
# the result is read from $LOCAL_RELEASE_STORE/.tmp/node_command_result_$$_${_node_index} 
# in format "StatusCode|Output"
__print_node_command_result() {
  local _node_index=$1
  local _node_name=${background_jobs_nodes[$_node_index]}
  local _config; local _config_arg
  echo "${bldgrn}$NODE_ENVIRONMENT${txtrst} node: $_node_index"
  echo
  local _user=${_node_name%@*}
  local _host=${_node_name#*@}
  local _path=${_host#*:}
  [[ "$_path" =~ .*\|.* ]] && _config=${_path#*|} || _config=""
  _path=${_path%|*}
  _host=${_host%:*}
  
  echo "  user    : $_user"
  echo "  host    : $_host"
  echo "  path    : $_path"
  [[ -n "$_config" ]] && echo "  config  : $_config"
  
  local _node_action_response=$(cat < $LOCAL_RELEASE_STORE/.tmp/node_command_result_$$_${_node_index})
  rm -f "$LOCAL_RELEASE_STORE/.tmp/node_command_result_$$_${_node_index}"
  local _status_code=${_node_action_response%|*}
  _node_action_response=${_node_action_response#*|}
  if [[ "$_status_code" = "0" ]]; then
    echo -n "  response: "; hint_message "$_node_action_response" 
  else
    echo -n "  response: "; [[ -z "$_node_action_response" ]] && error_message "failed" || error_message "$_node_action_response"
  fi
  echo 
  [[ "$_status_code" = "0" ]] && return 0 || return 1   
}



