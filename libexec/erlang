#!/usr/bin/env bash

# the local or remote (scp) directory where the built
# releases should be copied to
if [ -z "$RELEASE_STORE" ]
then
  RELEASE_STORE=".deliver"
fi

if [ -z "$REBAR_CONFIG" ]
then
  REBAR_OPTIONS=""
else
  REBAR_OPTIONS="-C $REBAR_CONFIG"
fi

REBAR_CMD="./rebar $REBAR_OPTIONS"

# sets the build host, user and path as deliver hosts and path
set_build_hosts() {
  # use build host and user for remote operations
  export HOSTS=$BUILD_HOST 
  export APP_USER=$BUILD_USER
  # use deliver to as built at destination
  export DELIVER_TO=$BUILD_AT  
}

# sets the deploy host, user and path as deliver hosts and path
set_deploy_hosts() {
  if [ "$DEPLOY_ENVIRONMENT" = "production" ]; then
    export HOSTS=$PRODUCTION_HOSTS 
    export APP_USER=$PRODUCTION_USER
  else 
    export HOSTS=$STAGING_HOSTS 
    export APP_USER=$STAGING_USER
    export DELIVER_TO=$TEST_AT  
  fi
}

# sets all required config variables and defaults for deploy strategies
require_deploy_config() {
  DEPLOY_ENVIRONMENT="${DEPLOY_ENVIRONMENT:=staging}"
  TEST_AT="${DELIVER_TO:=$TEST_AT}"

  REQUIRED_CONFIGS+=("APP")

  if [ "$DEPLOY_ENVIRONMENT" = "production" ]; then
    REQUIRED_CONFIGS+=("PRODUCTION_HOSTS")
    REQUIRED_CONFIGS+=("PRODUCTION_USER")
    REQUIRED_CONFIGS+=("DELIVER_TO")  
  else
    REQUIRED_CONFIGS+=("STAGING_HOSTS")
    REQUIRED_CONFIGS+=("STAGING_USER")
    REQUIRED_CONFIGS+=("TEST_AT")  
  fi  
  
  OPTIONAL_CONFIGS+=("VERSION")
}


# clean fetch of rebar dependencies on the remote build host
rebar_get_and_update_deps() {
  __exec_if_defined "pre_rebar_get_and_update_deps"

  status "Fetching rebar dependencies"
  __remote "
    set -e
    [ -f ~/.profile ] && source ~/.profile
    cd $DELIVER_TO $SILENCE
    $REBAR_CMD update-deps get-deps $SILENCE
  "

  __exec_if_defined "pos_rebar_get_and_update_deps"
}

# compiles the sources on the remote build host
rebar_clean_compile() {
  __exec_if_defined "pre_rebar_clean_compile"

  status "Compiling sources"
  __remote "
    set -e
    [ -f ~/.profile ] && source ~/.profile
    cd $DELIVER_TO $SILENCE
    $REBAR_CMD clean skip_deps=true $SILENCE
    $REBAR_CMD compile $SILENCE
  "

  __exec_if_defined "post_rebar_clean_compile"
}

# generates the release on the remote build host
rebar_renerate() {
  __exec_if_defined "pre_rebar_renerate"

  status "Generating release"
  __remote "
    set -e
    [ -f ~/.profile ] && source ~/.profile
    cd $DELIVER_TO $SILENCE
    $REBAR_CMD -f generate $SILENCE
  "

  __exec_if_defined "post_rebar_renerate"
}

# creates a tar.gz of the built release
archive_release_dir() {
  __detect_remote_release_dir
  __detect_remote_release_version
  status "Building archive of release ${RELEASE_VERSION}"  
  # create tar
  __remote "
    set -e
    [ -f ~/.profile ] && source ~/.profile
    tar -zcpf $RELEASE_DIR/../${APP}_${RELEASE_VERSION}.tar.gz -C $RELEASE_DIR/.. ${APP} $SILENCE
  "
}

# copies the generated release from the remote build host
# to the release store. takes the release type as parameter
# (release|upgrade)
copy_release_to_release_store() {
  __detect_remote_release_dir
  __detect_remote_release_version
  __detect_release_store_type
  local _release_type="$1"
  local _release_file="$RELEASE_DIR/../${APP}_${RELEASE_VERSION}.tar.gz"  
  
  if [ "$RELEASE_STORE_TYPE" = "s3" ]; then  
    local _aws_script_content=$(cat $BASE_PATH/libexec/aws)
    __remote "
      set -e
      [ -f ~/.profile ] && source ~/.profile
      cd $(dirname ${_release_file}) $SILENCE
      AWS_ARGUMENTS=\"put ${AWS_BUCKET_NAME}/${APP}_${RELEASE_VERSION}.${_release_type}.tar.gz $(basename ${_release_file})\" AWS_ACCESS_KEY_ID=\"$AWS_ACCESS_KEY_ID\" AWS_SECRET_ACCESS_KEY=\"$AWS_SECRET_ACCESS_KEY\" perl $SILENCE <<'EOF'${_aws_script_content}EOF ;"
  elif [ "$RELEASE_STORE_TYPE" = "local" ]; then 
    status "Copying $(basename $_release_file) to release store"    
    __create_directory_in_release_store "/releases"
    __exec "scp -o ConnectTimeout=\"$SSH_TIMEOUT\"  -p $BUILD_USER@$BUILD_HOST:${_release_file} ${RELEASE_STORE}/releases/${APP}_${RELEASE_VERSION}.${_release_type}.tar.gz"
  else 
    error_message "Cannot copy releases to store for store type ${RELEASE_STORE_TYPE}"; exit 2
  fi

}

# copies the generated appup files from the remote build host
# to the release store
copy_appups_to_release_store() {
  __detect_remote_release_dir
  RELEASE_VERSION="" # redetect new version
  __detect_remote_release_version
  local _old_version=$1
  local _appup_files="$RELEASE_DIR/lib/*/ebin/*.appup"  
  status "Copying generated appup files to release store /appup/${_old_version}-${RELEASE_VERSION}"
  # create release store directory if it is a local directory
  __create_directory_in_release_store "/appup/${_old_version}-${RELEASE_VERSION}"
  __exec "scp -o ConnectTimeout=\"$SSH_TIMEOUT\"  -p $BUILD_USER@$BUILD_HOST:${_appup_files} ${RELEASE_STORE}/appup/${_old_version}-${RELEASE_VERSION}"
}


# reselects the release or update to deploy to productions hosts
# from the release store. Sets the RELEASE_FILE and VERSION variables
# takes the release type as parameter (release|update|upgrade)
select_release_from_store() {
  local _release_type="$1"
  if ! [ -z $VERSION ]; then
    RELEASE_FILE="${APP}_${VERSION}.${_release_type}.tar.gz"
    return
  else
    __detect_release_store_type
    local _release_files=( $(__get_releases_in_store "$_release_type") )
    if [ ${#_release_files[@]} -eq 1 ]; then
      RELEASE_FILE=$(basename ${_release_files[0]})
      VERSION=${RELEASE_FILE/${APP}_/}
      VERSION=${VERSION/.${_release_type}.tar.gz/}
    elif [ ${#_release_files[@]} -eq 0 ]; then
      error_message "No $_release_type(s) found in ${RELEASE_STORE_TYPE} release store."
      hint_message "You can build one with the ./edeliver build $_release_type task."
      exit 2
    else
      status "Selecting release"
      hint_message "Found ${#_release_files[@]} different versions to deploy."
      hint_message "Type the version you want to deploy"
      hint_message "or set VERSION=X in the command line."
      hint_message "Versions:"
      local _release_file
      for _release_file in "${_release_files[@]}"; do
        local _current_version=$(__release_version_from_archive_name "$_release_file" "$_release_type")
        hint_message " $_current_version"
      done
      hint_message "Enter Version:"
      read VERSION
      RELEASE_FILE="${APP}_${VERSION}.${_release_type}.tar.gz"      
    fi
  fi  
}

# lists the available releases in the store
list_releases_in_store() {
  local _release_type="$1"
  __detect_release_store_type
  status "Listing ${APP} releases in ${RELEASE_STORE_TYPE} release store"
  local _release_files=( $(__get_releases_in_store "$_release_type") )
  local _app_column_width=${#APP}
  [[ $_app_column_width -lt 11 ]] && _app_column_width="11"
  printf "\n %${_app_column_width}s | Version |    Type | File\n-" "Application"
  for i in $(seq 1 $_app_column_width); do printf "-"; done
  printf '-' {1.."$_app_column_width"}
  printf "+---------+---------+---------------------\n"
  local _release_file
  for _release_file in "${_release_files[@]}"; do
    # echo $_release_file
    local _release_version=$(__release_version_from_archive_name "$_release_file" "$_release_type")
    local _removed_app_name=${_release_file/${APP}_/}
    local _removed_archive_extension=${_removed_app_name/\.tar\.gz/}
    local _current_release_type=${_removed_archive_extension/$_release_version./}
    printf " %${_app_column_width}s | %7s | %7s | %s\n" "$APP" "$_release_version"  "$_current_release_type" "$_release_file"
    
  done
}

# gets the names of the release packages in the release store.
__get_releases_in_store() {
  local _release_type="$1"
  __detect_release_store_type
  if [ "$RELEASE_STORE_TYPE" = "s3" ]; then
    AWS_ACCESS_KEY_ID="$AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY="$AWS_SECRET_ACCESS_KEY ${BASE_PATH}/libexec/aws ls ${AWS_BUCKET_NAME} 2>/dev/null | grep -o "${APP}_.*.${_release_type}.tar.gz"
  elif [ "$RELEASE_STORE_TYPE" = "local" ]; then
    local _release_file;
    for _release_file in $(ls -1 ${RELEASE_STORE}/releases/${APP}_*.${_release_type}.tar.gz); do
      echo $(basename $_release_file)
    done
  else 
    error_message "Cannot detect releases in store for store type ${RELEASE_STORE_TYPE}"; exit 2    
  fi
}


# copies the release archive to the production hosts to the DELIVER_TO path.
# the current release file and version must be set in the
# RELEASE_FILE and VERSION variables. an optional subdirectory can be passed
# as argument (with a leading slash, but no tailing)
upload_release_archive() {
  local _subdirectory=${1-}
  status "Uploading archive of release $VERSION"
  __detect_release_store_type
  if [ "$RELEASE_STORE_TYPE" = "s3" ]; then
    local _aws_script_content=$(cat $BASE_PATH/libexec/aws)
    __remote "
      set -e
      [ -f ~/.profile ] && source ~/.profile
      mkdir -p ${DELIVER_TO}${_subdirectory} $SILENCE
      cd ${DELIVER_TO}${_subdirectory} $SILENCE
      AWS_ARGUMENTS=\"get ${AWS_BUCKET_NAME}/${RELEASE_FILE} \" AWS_ACCESS_KEY_ID=\"$AWS_ACCESS_KEY_ID\" AWS_SECRET_ACCESS_KEY=\"$AWS_SECRET_ACCESS_KEY\" perl > ${APP}_${VERSION}.tar.gz 2>/dev/null <<'EOF'${_aws_script_content}EOF ;"
  elif [ "$RELEASE_STORE_TYPE" = "local" ]; then
    __remote "
      set -e
      [ -f ~/.profile ] && source ~/.profile
      mkdir -p ${DELIVER_TO}${_subdirectory} $SILENCE
    "  
    __parallel_scp "${RELEASE_STORE}/releases/${RELEASE_FILE}" "${DELIVER_TO}${_subdirectory}/${APP}_${VERSION}.tar.gz"
  else 
    error_message "Cannot upload release for store type ${RELEASE_STORE_TYPE}"; exit 2    
  fi  
}

# upgrades the remote hosts with running nodes to
# the new release version.
upgrade_release() {
  status "Upgrading release to $VERSION"  
  __remote "
    set -e
    [ -f ~/.profile ] && source ~/.profile
    cd ${DELIVER_TO}/${APP} $SILENCE
    bin/${APP} upgrade ${APP}_${VERSION} $SILENCE
  "
}

# installs a release at all production hosts
remote_extract_release_archive() {
  local _archive="${APP}_${VERSION}.tar.gz"
  status "Extracting archive ${_archive}"
  __remote "
    set -e
    [ -f ~/.profile ] && source ~/.profile
    cd $DELIVER_TO $SILENCE
    tar -xzvf ${_archive} $SILENCE
  "  
}

# gets the sha hash of the latest commit of the branch to deploy
get_latest_commit() {
  __exec "git rev-parse $BRANCH;"
}

# checks the given commit out on the remote build host
git_checkout_remote() {
  local _revision=$1
  status "Checking out $_revision"
  __remote "
    set -e
    [ -f ~/.profile ] && source ~/.profile
    cd $DELIVER_TO $SILENCE
    git checkout $_revision $SILENCE
  "
}

# stashes the build directory on the remote build host.
# stashing instead of cleaning prevent losing manual changes
# and prevent damage if BUILD_AT directory is not configured
# properly. 
# keeps max 10 stashes because the stashed files may be
# quite large because that are previous builds
git_stash_remote() {
  status "Stashing build directory on remote build host"
  __remote "
    set -e
    [ -f ~/.profile ] && source ~/.profile
    cd $DELIVER_TO $SILENCE
    [[ \$(git stash list | wc -l) -gt 0 ]] && _oldest_stash=\$(git stash list | tail -1 | grep -o 'stash@{[0-9]\+}' | grep -o '[0-9]\+') || _oldest_stash=0
    [[ \${_oldest_stash} -gt 50 ]] && git stash drop stash@{\$_oldest_stash} $SILENCE
    git stash --all $SILENCE  
  "
}

# renames the release directory on the remote build host
# by adding the release version to the release folder name
rename_release_add_version() {
  __detect_remote_release_dir
  __detect_remote_release_version
  status "Moving old release to ${APP}_${RELEASE_VERSION}"
  __remote "
    set -e
    [ -f ~/.profile ] && source ~/.profile
    cd $RELEASE_DIR/.. $SILENCE
    mv ${APP} ${APP}_${RELEASE_VERSION} $SILENCE
  "
  
}

# generates the upgrade from the old version to the new version
rebar_generate_appup() {
  __detect_remote_release_dir
  RELEASE_VERSION="" # redetect new version
  __detect_remote_release_version
  local _old_version=$1
  status "Generating default appup scripts for release ${RELEASE_VERSION}"
  __remote "
    set -e
    [ -f ~/.profile ] && source ~/.profile
    cd $DELIVER_TO $SILENCE
    $REBAR_CMD generate-appups previous_release=${APP}_${_old_version} $SILENCE
  "
}

# copies the custom appups from the release store to the current release
# on the build host. this overrides previously generated default appups
copy_appups_from_release_store_to_build_host() {
  __detect_remote_release_dir
  RELEASE_VERSION="" # redetect new version
  __detect_remote_release_version
  local _old_version=$1
  if [ -d "$RELEASE_STORE/appup/${_old_version}-${RELEASE_VERSION}" ]; then
    local _num_scripts=$(ls -1 $RELEASE_STORE/appup/${_old_version}-${RELEASE_VERSION}/*.appup | wc -l)
    status "Overwriting appups with ${_num_scripts// /} custom scripts from /appup/${_old_version}-${RELEASE_VERSION}/"
    for appup_file in $RELEASE_STORE/appup/${_old_version}-${RELEASE_VERSION}/*.appup; do
      local _appup_base_name=$(basename $appup_file)
      local _appup_app_name=${_appup_base_name%.*}
      __exec "echo \"Copying $RELEASE_STORE/appup/${_old_version}-${RELEASE_VERSION}/${_appup_base_name}\" to $BUILD_USER@$BUILD_HOST:${RELEASE_DIR}/lib/${_appup_app_name}*/ebin/${_appup_base_name}"
      __exec "scp -o ConnectTimeout=\"$SSH_TIMEOUT\" -p $RELEASE_STORE/appup/${_old_version}-${RELEASE_VERSION}/${_appup_base_name} $BUILD_USER@$BUILD_HOST:${RELEASE_DIR}/lib/${_appup_app_name}*/ebin/${_appup_base_name}"
    done
  else 
    status "Using default appup scripts. No custom scripts in /appup/${_old_version}-${RELEASE_VERSION}/"
  fi
}

# generates the upgrade from the old version to the new version
rebar_generate_upgrade() {
  __detect_remote_release_dir
  RELEASE_VERSION="" # redetect new version
  __detect_remote_release_version
  local _old_version=$1
  status "Generating upgrade to version ${RELEASE_VERSION}"
  __remote "
    set -e
    [ -f ~/.profile ] && source ~/.profile
    cd $DELIVER_TO $SILENCE
    $REBAR_CMD generate-upgrade previous_release=${APP}_${_old_version} $SILENCE
  "
}

# generates the appup files from the old version to the new version
rebar_generate_appup() {
  __detect_remote_release_dir
  RELEASE_VERSION="" # redetect new version
  __detect_remote_release_version
  local _old_version=$1
  status "Generating appups for version ${RELEASE_VERSION}"
  __remote "
    set -e
    [ -f ~/.profile ] && source ~/.profile
    cd $DELIVER_TO $SILENCE
    $REBAR_CMD generate-appups previous_release=${APP}_${_old_version} $SILENCE
  "
}




# detects the directory that contains the generated release
# on the remote build host
__detect_remote_release_dir() {
  if ! [ -z $RELEASE_DIR ]; then
    return
  else
    local _release_directories=($(__remote "
      set -e
      [ -f ~/.profile ] && source ~/.profile
      cd $DELIVER_TO $SILENCE
      find ./ -name RELEASES -exec readlink -f {} \; | grep -E $APP/releases/RELEASES\$
    "))  
    if [ ${#_release_directories[@]} -eq 1 ]; then
      RELEASE_DIR=${_release_directories[0]/\/releases\/RELEASES/}
    else
      error_message "Failed to detect generated release at\n$APP_USER@$HOSTS:$DELIVER_TO\n"
      error_message "Please set RELEASE_DIR in the config file to fix that,\nor check that the APP variable is set correctly."
      if [ ${#_release_directories[@]} -gt 1 ]; then
        hint_message "Maybe one of these directories contains the relase:"
        for _dir in "${_release_directories[@]}"; do
          hint_message "  ${_dir/\/releases\/RELEASES/}"
        done
      fi
      exit 1
    fi
  fi
}

# detectes the current version of the generated release
# on the remote build host
__detect_remote_release_version() {
  if ! [ -z $RELEASE_VERSION ]; then
    return
  else
    local _releases=($(__remote "
      ls -Ad $RELEASE_DIR/releases/*/
    "))
    if [ ${#_releases[@]} -eq 1 ]; then
      RELEASE_VERSION=`basename ${_releases[0]}`
    else
      error_message "Failed to detect generated release version at\n$APP_USER@$HOSTS:$RELEASE_DIR/releases/\n"
      error_message "Please set RELEASE_VERSION=x"
      if [ ${#_releases[@]} -gt 1 ]; then
        hint_message "Detected several releases:"
        for _release in "${_releases[@]}"; do
          hint_message " $(basename $_release)"
        done
      fi
      exit 1
    fi
  fi
}

# detects the type of the release store. sets RELEASE_STORE_TYPE either
# to "local", "remote" or "s3" and also the following environment variables
# depending on the detected release store type:
#
# AWS_SECRET_ACCESS_KEY (for s3)
# AWS_SECRET_ACCESS_KEY (for s3)
# AWS_BUCKET_NAME (for s3)
__detect_release_store_type() {
  if [[ "$RELEASE_STORE" =~ ^[sS]3://[^@]+@[^:]+:.+$ ]]; then
    local _s3location=${RELEASE_STORE/#[sS]3:\/\//}
    AWS_ACCESS_KEY_ID=${_s3location%%@*}
    _s3location=${_s3location##*@}
    AWS_SECRET_ACCESS_KEY=${_s3location%%:*}
    _s3location=${_s3location##*:}
    AWS_BUCKET_NAME=${_s3location%%*:}
  fi

  if [[ "$RELEASE_STORE" =~ ^[sS]3://[^@]+@[^:]+:.+$ ]] && [[ -n \"${AWS_ACCESS_KEY_ID}\" ]] && [[ -n \"${AWS_SECRET_ACCESS_KEY}\" ]] && [[ -n \"${AWS_BUCKET_NAME}\" ]]; then  
    RELEASE_STORE_TYPE="s3"
  elif [[ "$RELEASE_STORE" =~ ^[^@]+@[^:]+:.+$ ]]; then
    RELEASE_STORE_TYPE="remote"
  else 
    RELEASE_STORE_TYPE="local"
  fi
}

# creates a subdirectory or subdirectories on the release store
__create_directory_in_release_store() {
  local _directory=$1
  # create release store directory if it is a local directory
  ! [[ "$RELEASE_STORE" =~ .*:.* ]] && __exec "mkdir -p ${RELEASE_STORE}${_directory}"
  # TODO: create directories also on remote stores
}

# gets the release version from the release archive name
# $1 = release file name
# $2 = release type (optional)
__release_version_from_archive_name() {
  local _release_type=${2}
  _release_type=${_release_type:=*}
  local _removed_app_name=${1/${APP}_/}
  local _removed_archive_extension=${_removed_app_name/\.tar\.gz/}
  local _removed_release_type=${_removed_archive_extension%.${_release_type}}
  echo ${_removed_release_type}
}

# copy a file to all remote production hosts in parallel
__parallel_scp() {
  local _source_file="$1"
  local _destination_dir="$2"
  local _hosts="${3:-"$HOSTS_APP_USER"}"
  if [ "${MODE}" = "compact" ]; then
    local _options=" -q"
  else 
    local _options=""
  fi
  
  background_jobs_pids=()
  background_jobs=()  

  __log "${_hosts} : $_remote_job"
  
    
  for _host in $_hosts
  do
    if [ "$SKIP_COPYING_EXISTING_FILES" = "skip" ]; then
      local _local_md5=$(__local_md5 $_source_file)
      local _remote_md5=$(__remote_md5 $_host "$_destination_dir")
      if [[ -n "$_local_md5" ]] && [[ -n "$_remote_md5" ]] && [[ "$_local_md5" = "$_remote_md5" ]]; then
        __exec "echo \"file \$(basename \$_source_file) already exists on host \$_host (checksum: \$_remote_md5)\""
        continue       
      fi
    fi
    __exec "echo \"copying $_source_file to $_host:$_destination_dir\""
    scp -o ConnectTimeout="$SSH_TIMEOUT" $_options "$_source_file" "$_host:$_destination_dir" &
    background_jobs_pids+=("$!")
    local _background_job="scp -o ConnectTimeout=$SSH_TIMEOUT $_options $_source_file $_host:$_destination_dir $SILENCE"
    background_jobs+=("$_background_job")
  done

  __monitor_background_jobs
}

# gets the md5 checksum of a release in the local release store
__local_md5() {
  local _file_name="$1"
  if [ -z "$LOCAL_MD5_COMMAND" ]; then
    LOCAL_MD5_COMMAND=$(which md5)
    if [ $? -eq 1 ]; then
      LOCAL_MD5_COMMAND=$(which md5sum)
      [ $? -eq 1 ] && LOCAL_MD5_COMMAND=""
    fi
  fi
  if ! [ -z "$LOCAL_MD5_COMMAND" ]; then
    $LOCAL_MD5_COMMAND ${_file_name} | grep -o "[0-9a-fA-F]\{32\}"
  else 
    echo ""    
  fi
}

# gets the md5 checksum of a release file on the remote host
__remote_md5() {
  local _remote_host="$1"
  local _remote_file_name="$2"
  _remote_job="
    if [ -f \"${_remote_file_name}\" ]; then
      if [ -z \"\$REMOTE_MD5_COMMAND\" ]; then
        REMOTE_MD5_COMMAND=\$(which md5)
        if [ \$? -eq 1 ]; then
          REMOTE_MD5_COMMAND=\$(which md5sum)
          [ \$? -eq 1 ] && LOCAL_MD5_COMMAND=""
        fi
      fi
      if ! [ -z \"\$REMOTE_MD5_COMMAND\" ]; then
        \$REMOTE_MD5_COMMAND ${_remote_file_name} | grep -o \"[0-9a-fA-F]\\{32\\}\"
      else 
        echo \"\"
      fi  
    else
        echo \"\"
    fi
  "  
  ssh -o ConnectTimeout="$SSH_TIMEOUT" "$_remote_host" "$_remote_job"
}

begin() {
  case "$COMMAND" in
    (build)
      local _message="${bldgrn}BUILDING $(upcase "${COMMAND_INFO}")${bldgrn} OF $(upcase "${APP}") APP ON BUILD HOST${txtrst}"      
    ;;
    (deploy)
      local _host_color="${bldylw}"
      [ "$DEPLOY_ENVIRONMENT" = "production" ] && _host_color="${bldred}"
      local _message="${bldgrn}DEPLOYING ${bldylw}$(upcase "${COMMAND_INFO}")${bldgrn} OF $(upcase "${APP}") APP TO ${_host_color}$(upcase ${DEPLOY_ENVIRONMENT}) HOSTS${txtrst}"      
    ;;
    (*)
      local _message="${bldgrn}$(upcase "edeliver ${APP} with $COMMAND command")${txtrst}"
    ;;
  esac
  echo -e "\n$_message\n"  
  __log "$_message"
}


# If we reach this step, delivery was successfull
#
finish() {
  case "$COMMAND" in
    (build)
      local _message="${bldgrn}$(upcase "${COMMAND_INFO} BUILD OF $APP WAS SUCCESSFUL!")${txtrst}"
      ;;
    (deploy)
      local _message="${bldgrn}DEPLOYED $(upcase "${COMMAND_INFO} TO ${DEPLOY_ENVIRONMENT}!")${txtrst}"      
    ;;
    (*)
      local _message="${bldgrn}$(upcase "$COMMAND DONE!")${txtrst}"
    ;;
  esac
  echo -e "\n$_message\n"
  __log "$_message"
  __log "===========================================================\n"
}
