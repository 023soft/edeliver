#!/usr/bin/env bash

# the local or remote (scp) directory where the built
# releases should be copied to
if [ -z "$RELEASE_STORE" ]
then
  RELEASE_STORE=".deliver"
fi

if [ -z "$REBAR_CONFIG" ]
then
  REBAR_OPTIONS=""
else
  REBAR_OPTIONS="-C $REBAR_CONFIG"
fi

REBAR_CMD="./rebar $REBAR_OPTIONS"

# sets the build host, user and path as deliver hosts and path
set_build_hosts() {
  # use build host and user for remote operations
  export HOSTS=$BUILD_HOST 
  export APP_USER=$BUILD_USER
  # use deliver to as built at destination
  export DELIVER_TO=$BUILD_AT  
}

# sets the deploy host, user and path as deliver hosts and path
set_deploy_hosts() {
  if [ "$DEPLOY_ENVIRONMENT" = "production" ]; then
    export HOSTS=$PRODUCTION_HOSTS 
    export APP_USER=$PRODUCTION_USER
  else 
    export HOSTS=$STAGING_HOSTS 
    export APP_USER=$STAGING_USER
    export DELIVER_TO=$TEST_AT  
  fi
}

# sets all required config variables and defaults for deploy strategies
require_deploy_config() {
  DEPLOY_ENVIRONMENT="${DEPLOY_ENVIRONMENT:=staging}"
  TEST_AT="${DELIVER_TO:=$TEST_AT}"

  REQUIRED_CONFIGS+=("APP")

  if [ "$DEPLOY_ENVIRONMENT" = "production" ]; then
    REQUIRED_CONFIGS+=("PRODUCTION_HOSTS")
    REQUIRED_CONFIGS+=("PRODUCTION_USER")
    REQUIRED_CONFIGS+=("DELIVER_TO")  
  else
    REQUIRED_CONFIGS+=("STAGING_HOSTS")
    REQUIRED_CONFIGS+=("STAGING_USER")
    REQUIRED_CONFIGS+=("TEST_AT")  
  fi  
  
  OPTIONAL_CONFIGS+=("VERSION")
}


# clean fetch of rebar dependencies on the remote build host
rebar_get_and_update_deps() {
  __exec_if_defined "pre_rebar_get_and_update_deps"

  status "Fetching rebar dependencies"
  __remote "
    set -e
    [ -f ~/.profile ] && source ~/.profile
    cd $DELIVER_TO $SILENCE
    $REBAR_CMD update-deps get-deps $SILENCE
  "

  __exec_if_defined "pos_rebar_get_and_update_deps"
}

# compiles the sources on the remote build host
rebar_clean_compile() {
  __exec_if_defined "pre_rebar_clean_compile"

  status "Compiling sources"
  __remote "
    set -e
    [ -f ~/.profile ] && source ~/.profile
    cd $DELIVER_TO $SILENCE
    $REBAR_CMD clean compile $SILENCE
  "

  __exec_if_defined "post_rebar_clean_compile"
}

# generates the release on the remote build host
rebar_renerate() {
  __exec_if_defined "pre_rebar_renerate"

  status "Generating release"
  __remote "
    set -e
    [ -f ~/.profile ] && source ~/.profile
    cd $DELIVER_TO $SILENCE
    $REBAR_CMD -f generate $SILENCE
  "

  __exec_if_defined "post_rebar_renerate"
}

# creates a tar.gz of the built release
archive_release_dir() {
  __detect_remote_release_dir
  __detect_remote_release_version
  status "Building archive of release ${RELEASE_VERSION}"  
  # create tar
  __remote "
    set -e
    [ -f ~/.profile ] && source ~/.profile
    tar -zcpf $RELEASE_DIR/../${APP}_${RELEASE_VERSION}.tar.gz -C $RELEASE_DIR/.. ${APP} $SILENCE
  "
}

# copies the generated release from the remote build host
# to the release store
copy_release_to_release_store() {
  __detect_remote_release_dir
  __detect_remote_release_version
  local _release_file="$RELEASE_DIR/../${APP}_${RELEASE_VERSION}.tar.gz"  
  status "Copying $(basename $_release_file) to release store"
  __create_directory_in_release_store "/releases"
  __exec "scp -o ConnectTimeout=\"$SSH_TIMEOUT\"  -p $BUILD_USER@$BUILD_HOST:${_release_file} ${RELEASE_STORE}/releases"
}

# copies the generated appup files from the remote build host
# to the release store
copy_appups_to_release_store() {
  __detect_remote_release_dir
  RELEASE_VERSION="" # redetect new version
  __detect_remote_release_version
  local _old_version=$1
  local _appup_files="$RELEASE_DIR/lib/*/ebin/*.appup"  
  status "Copying generated appup files to release store /appup/${_old_version}-${RELEASE_VERSION}"
  # create release store directory if it is a local directory
  __create_directory_in_release_store "/appup/${_old_version}-${RELEASE_VERSION}"
  __exec "scp -o ConnectTimeout=\"$SSH_TIMEOUT\"  -p $BUILD_USER@$BUILD_HOST:${_appup_files} ${RELEASE_STORE}/appup/${_old_version}-${RELEASE_VERSION}"
}


# reselects the release or update to deploy to productions hosts
# from the release store. Sets the RELEASE_FILE and VERSION variables
select_release_from_store() {
  if ! [ -z $VERSION ]; then
    RELEASE_FILE="${APP}_${VERSION}.tar.gz"
    return
  else
    if [[ "${RELEASE_STORE}/releases" =~ .*:.* ]]; then
      # TODO: list releases in remote store
      error_message "Failed to detect release version to install."
      error_message "Autodetection of releases in remote release stores is not supported."
      hint_message "Please set VERSION=X in the command line"
      exit 1
    fi
    _release_files=( $(ls ${RELEASE_STORE}/releases/${APP}_*.tar.gz) )
    if [ ${#_release_files[@]} -eq 1 ]; then
      RELEASE_FILE=$(basename ${_release_files[0]})
      VERSION=${RELEASE_FILE/${APP}_/}
      VERSION=${VERSION/.tar.gz/}
    else
      status "Selecting release"
      hint_message "Found different versions to deploy."
      hint_message "Type the version you want to deploy"
      hint_message "or set VERSION=X in the command line."
      hint_message "Versions:"
      for _release_file in "${_release_files[@]}"; do
        local _current_version=$(__release_version_from_archive_name $(basename $_release_file))
        hint_message " $_current_version"
      done
      hint_message "Enter Version:"
      read VERSION
      RELEASE_FILE="${APP}_${VERSION}.tar.gz"      
    fi
  fi  
}

# copies the release archive to the production hosts to the DELIVER_TO path.
# the current release file and version must be set in the
# RELEASE_FILE and VERSION variables. an optional subdirectory can be passed
# as argument (with a leading slash, but no tailing)
upload_release_archive() {
  local _subdirectory=${1-}
  status "Uploading archive of release $VERSION"
  __remote "
    set -e
    [ -f ~/.profile ] && source ~/.profile
    mkdir -p ${DELIVER_TO}${_subdirectory} $SILENCE
  "  
  __parallel_scp "${RELEASE_STORE}/releases/${RELEASE_FILE}" "${DELIVER_TO}${_subdirectory}/${RELEASE_FILE}"
}

# makes an update release permanent. which means the current node
# is not upgraded while running, but on next start the new release
# will be booted
make_release_permanent() {
  status "Making release $VERSION permanent"  
  __remote "
    set -e
    [ -f ~/.profile ] && source ~/.profile
    cd ${DELIVER_TO}/${APP} $SILENCE
    bin/${APP} update ${APP}_${VERSION} $SILENCE
  "
}

# upgrades the remote hosts with running nodes to
# the new release version.
upgrade_release() {
  status "Upgrading release to $VERSION"  
  __remote "
    set -e
    [ -f ~/.profile ] && source ~/.profile
    cd ${DELIVER_TO}/${APP} $SILENCE
    bin/${APP} upgrade ${APP}_${VERSION} $SILENCE
  "
}

# installs a release at all production hosts
remote_extract_release_archive() {
  status "Extracting archive $(basename $RELEASE_FILE)"
  __remote "
    set -e
    [ -f ~/.profile ] && source ~/.profile
    cd $DELIVER_TO $SILENCE
    tar -xzvf $RELEASE_FILE $SILENCE
  "  
}

# gets the sha hash of the latest commit of the branch to deploy
get_latest_commit() {
  __exec "git rev-parse $BRANCH;"
}

# checks the given commit out on the remote build host
git_checkout_remote() {
  local _revision=$1
  status "Checking out $_revision"
  __remote "
    set -e
    [ -f ~/.profile ] && source ~/.profile
    cd $DELIVER_TO $SILENCE
    git checkout $_revision $SILENCE
  "
}

# stashes the build directory on the remote build host.
# stashing instead of cleaning prevent losing manual changes
# and prevent damage if BUILD_AT directory is not configured
# properly. 
# keeps max 10 stashes because the stashed files may be
# quite large because that are previous builds
git_stash_remote() {
  status "Stashing build directory on remote build host"
  __remote "
    set -e
    [ -f ~/.profile ] && source ~/.profile
    cd $DELIVER_TO $SILENCE
    [[ \$(git stash list | wc -l) -gt 0 ]] && _oldest_stash=\$(git stash list | tail -1 | grep -o 'stash@{[0-9]\+}' | grep -o '[0-9]\+') || _oldest_stash=0
    [[ \${_oldest_stash} -gt 50 ]] && git stash drop stash@{\$_oldest_stash} $SILENCE
    git stash --all $SILENCE  
  "
}

# renames the release directory on the remote build host
# by adding the release version to the release folder name
rename_release_add_version() {
  __detect_remote_release_dir
  __detect_remote_release_version
  status "Moving old release to ${APP}_${RELEASE_VERSION}"
  __remote "
    set -e
    [ -f ~/.profile ] && source ~/.profile
    cd $RELEASE_DIR/.. $SILENCE
    mv ${APP} ${APP}_${RELEASE_VERSION} $SILENCE
  "
  
}

# generates the upgrade from the old version to the new version
rebar_generate_appup() {
  __detect_remote_release_dir
  RELEASE_VERSION="" # redetect new version
  __detect_remote_release_version
  local _old_version=$1
  status "Generating default appup scripts for release ${RELEASE_VERSION}"
  __remote "
    set -e
    [ -f ~/.profile ] && source ~/.profile
    cd $DELIVER_TO $SILENCE
    $REBAR_CMD generate-appups previous_release=${APP}_${_old_version} $SILENCE
  "
}

# copies the custom appups from the release store to the current release
# on the build host. this overrides previously generated default appups
copy_appups_from_release_store_to_build_host() {
  __detect_remote_release_dir
  RELEASE_VERSION="" # redetect new version
  __detect_remote_release_version
  local _old_version=$1
  local _num_scripts=$(ls -1 $RELEASE_STORE/appup/${_old_version}-${RELEASE_VERSION}/*.appup | wc -l)
  status "Overwriting appups with ${_num_scripts// /} custom scripts from /appup/${_old_version}-${RELEASE_VERSION}/"
  for appup_file in $RELEASE_STORE/appup/${_old_version}-${RELEASE_VERSION}/*.appup; do
    local _appup_base_name=$(basename $appup_file)
    local _appup_app_name=${_appup_base_name%.*}
    __exec "echo \"Copying $RELEASE_STORE/appup/${_old_version}-${RELEASE_VERSION}/${_appup_base_name}\" to $BUILD_USER@$BUILD_HOST:${RELEASE_DIR}/lib/${_appup_app_name}*/ebin/${_appup_base_name}"
    __exec "scp -o ConnectTimeout=\"$SSH_TIMEOUT\" -p $RELEASE_STORE/appup/${_old_version}-${RELEASE_VERSION}/${_appup_base_name} $BUILD_USER@$BUILD_HOST:${RELEASE_DIR}/lib/${_appup_app_name}*/ebin/${_appup_base_name}"
  done
}

# generates the upgrade from the old version to the new version
rebar_generate_upgrade() {
  __detect_remote_release_dir
  RELEASE_VERSION="" # redetect new version
  __detect_remote_release_version
  local _old_version=$1
  status "Generating upgrade to version ${RELEASE_VERSION}"
  __remote "
    set -e
    [ -f ~/.profile ] && source ~/.profile
    cd $DELIVER_TO $SILENCE
    $REBAR_CMD generate-upgrade previous_release=${APP}_${_old_version} $SILENCE
  "
}

# generates the appup files from the old version to the new version
rebar_generate_appup() {
  __detect_remote_release_dir
  RELEASE_VERSION="" # redetect new version
  __detect_remote_release_version
  local _old_version=$1
  status "Generating appups for version ${RELEASE_VERSION}"
  __remote "
    set -e
    [ -f ~/.profile ] && source ~/.profile
    cd $DELIVER_TO $SILENCE
    $REBAR_CMD generate-appups previous_release=${APP}_${_old_version} $SILENCE
  "
}




# detects the directory that contains the generated release
# on the remote build host
__detect_remote_release_dir() {
  if ! [ -z $RELEASE_DIR ]; then
    return
  else
    local _release_directories=($(__remote "
      set -e
      [ -f ~/.profile ] && source ~/.profile
      cd $DELIVER_TO $SILENCE
      find ./ -name RELEASES -exec readlink -f {} \; | grep -E $APP/releases/RELEASES\$
    "))  
    if [ ${#_release_directories[@]} -eq 1 ]; then
      RELEASE_DIR=${_release_directories[0]/\/releases\/RELEASES/}
    else
      error_message "Failed to detect generated release at\n$APP_USER@$HOSTS:$DELIVER_TO\n"
      error_message "Please set RELEASE_DIR in the config file to fix that,\nor check that the APP variable is set correctly."
      if [ ${#_release_directories[@]} -gt 1 ]; then
        hint_message "Maybe one of these directories contains the relase:"
        for _dir in "${_release_directories[@]}"; do
          hint_message "  ${_dir/\/releases\/RELEASES/}"
        done
      fi
      exit 1
    fi
  fi
}

# detectes the current version of the generated release
# on the remote build host
__detect_remote_release_version() {
  if ! [ -z $RELEASE_VERSION ]; then
    return
  else
    local _releases=($(__remote "
      ls -Ad $RELEASE_DIR/releases/*/
    "))
    if [ ${#_releases[@]} -eq 1 ]; then
      RELEASE_VERSION=`basename ${_releases[0]}`
    else
      error_message "Failed to detect generated release version at\n$APP_USER@$HOSTS:$RELEASE_DIR/releases/\n"
      error_message "Please set RELEASE_VERSION=x"
      if [ ${#_releases[@]} -gt 1 ]; then
        hint_message "Detected several releases:"
        for _release in "${_releases[@]}"; do
          hint_message " $(basename $_release)"
        done
      fi
      exit 1
    fi
  fi
}

# creates a subdirectory or subdirectories on the release store
__create_directory_in_release_store() {
  local _directory=$1
  # create release store directory if it is a local directory
  ! [[ "$RELEASE_STORE" =~ .*:.* ]] && __exec "mkdir -p ${RELEASE_STORE}${_directory}"
  # TODO: create directories also on remote stores
}

# gets the release version from the release archive name
__release_version_from_archive_name() {
  local _removed_app_name=${1/${APP}_/}
  echo ${_removed_app_name/\.tar\.gz/}
}

# copy a file to all remote production hosts in parallel
__parallel_scp() {
  local _source_file="$1"
  local _destination_dir="$2"
  local _hosts="${3:-"$HOSTS_APP_USER"}"
  if [ "${MODE}" = "compact" ]; then
    local _options=" -q"
  else 
    local _options=""
  fi
  
  background_jobs_pids=()
  background_jobs=()  

  __log "${_hosts} : $_remote_job"

  for _host in $_hosts
  do    
    scp -o ConnectTimeout="$SSH_TIMEOUT" $_options "$_source_file" "$_host:$_destination_dir" &
    background_jobs_pids+=("$!")
    local _background_job="scp -o ConnectTimeout=$SSH_TIMEOUT $_options $_source_file $_host:$_destination_dir $SILENCE"
    background_jobs+=("$_background_job")
  done

  __monitor_background_jobs
}

begin() {
  case "$COMMAND" in
    (build)
      local _message="${bldgrn}BUILDING $(upcase "${COMMAND_INFO}")${bldgrn} OF $(upcase "${APP}") APP ON BUILD HOST${txtrst}"      
    ;;
    (deploy)
      local _host_color="${bldylw}"
      [ "$DEPLOY_ENVIRONMENT" = "production" ] && _host_color="${bldred}"
      local _message="${bldgrn}DEPLOYING ${bldylw}$(upcase "${COMMAND_INFO}")${bldgrn} OF $(upcase "${APP}") APP TO ${_host_color}$(upcase ${DEPLOY_ENVIRONMENT}) HOSTS${txtrst}"      
    ;;
    (*)
      local _message="${bldgrn}$(upcase "edeliver ${APP} with $COMMAND command")${txtrst}"
    ;;
  esac
  echo -e "\n$_message\n"  
  __log "$_message"
}


# If we reach this step, delivery was successfull
#
finish() {
  case "$COMMAND" in
    (build)
      local _message="${bldgrn}$(upcase "${COMMAND_INFO} BUILD OF $APP WAS SUCCESSFUL!")${txtrst}"
      ;;
    (deploy)
      local _message="${bldgrn}DEPLOYED $(upcase "${COMMAND_INFO} TO ${DEPLOY_ENVIRONMENT}!")${txtrst}"      
    ;;
    (*)
      local _message="${bldgrn}$(upcase "$COMMAND DONE!")${txtrst}"
    ;;
  esac
  echo -e "\n$_message\n"
  __log "$_message"
  __log "===========================================================\n"
}
