#!/usr/bin/env bash

# If script doesn't run all the way to the end,
# it will exit 2 == SIGINT (Interrupt)
# http://steve-parker.org/sh/trap.shtml
#
complain_if_interrupted() {
  trap "exit 2" 1 2 3 13 15
}

# Displays arg as an error message, red and sad
#
error_message() {
  echo -e "$bldred$@$txtrst"
}

# Displays arg as a hint message, yellow and optimistic
#
hint_message() {
  echo -e "$txtylw$@$txtrst"
}

# Displays arg as a success message, green and cheerful
#
success_message() {
  echo -e "$bldgrn$@$txtrst"
}

# Specific failure, fail the whole script
#
error() {
  error_message $1
  exit 1
}

# Command failed (not sure why), fail the whole script
#
fail() {
  error_message "\nNot entirely sure why this failed."
  hint_message "Re-run the command in verbose (-V|--verbose) or debug (-D|--debug) mode to gather more details about the failure."
  exit 1
}

# Command was successful
#
success() {
  success_message " DONE"
}

# Loads the .deliver file
#
load_app_config() {
  if [ ! -f $APP_CONFIG ]; then
    error "Could not find a .deliver/config file in the current directory"
  else
    . $APP_CONFIG
  fi
}

# Ensures all required configs are set, tries to be helpful by adding some
# sane defaults
#
default_app_config() {
  . "$BASE_PATH/libexec/config"
}

# If STRATEGY or SERVER are specified at the time of invoking, overwrite
# anything that has been set from other sources
#
apply_super_configs() {
  if [ $SUPER_STRATEGY ]; then
    STRATEGY=$SUPER_STRATEGY
  fi
  if [ $SUPER_SERVER ]; then
    SERVER=$SUPER_SERVER
  fi
}

# Progress indicator when running commands in the background
#
__progress() {
  local message=$1
  local style=${2:$txtwht}
  # Last process to have gone in the background (in this context),
  # is our command
  pid=$!

  echo -en "$style$message"

  # If the pid exists, the process is running; use . as status indicators
  while [ $(ps -eo pid | grep $pid) ]; do
    printf '.'
    sleep 0.5
  done

  # Wait until command finishes, otherwise fail
  wait $pid || fail
  # Grab the command's exit code
  status=$?

  # Anything but 0 means that it failed
  if [ $status = 0 ]; then
    success
  else
    fail
  fi
}

# Start the output with an empty line. It just looks better with spacing.
#
begin() {
  echo ""
}

# Wrapper to either run the command verbosely (inline),
# or silently (in the background)
#
__run() {
  if [ $VERBOSE ]; then
    echo -e "$bldylw\n$2$txtrst"
    eval $1
  else
    (eval $1) &
    __progress "$2"
  fi
}

# If we reach this step, delivery was successfull
#
finish() {
  echo "$bldgrn"
  echo "$APP deployed" | tr '[:lower:]' '[:upper:]'
  echo "$txtrst"
}

# Registers a new strategy in the global STRATEGIES array
#
register_strategy() {
  STRATEGIES=("${STRATEGIES[@]}" "$txtbld\n$1$txtrst - $2")
}

# List all available strategies
#
list_strategies() {
  echo -e "${STRATEGIES[@]}\n"
}

# Loads the correct deliver strategy
#
load_strategy_or_list_available_strategies() {
  # There are strategies that came with deliver itself...
  local public_strategies_path="$BASE_PATH/strategies"
  # You can now have a per-project strategy. I wanted to avoid a new
  # Capistrano, but this feature is super useful.If you have a private
  # strategy that can be open sourced, by all means, submit a pull request.
  local private_strategies_path="$DELIVERY_ROOT/.deliver/strategies"

  # Find all files in both the public & private strategies folders
  local available_strategies=$(find $public_strategies_path $private_strategies_path -regex '^[a-zA-Z0-9/.-]*$' -type f ! -iname 'readme*')

  # This will leak function names in the global namespace, but I can't think of
  # a better way to register strategies
  for strategy in $available_strategies; do
    . "$strategy"
  done

  # This will display strategies and then exit if deliver was run with
  # -s|--strategies flag
  strategies

  if [[ ! $available_strategies =~ $STRATEGY ]]; then
    error_message "\n'$STRATEGY' strategy does not exist. The available strategies are:"
    list_strategies
    exit 1
  else
    for strategy in $available_strategies; do
      [[ ! $strategy =~ $STRATEGY ]] && continue
      . "$strategy" && break
    done
  fi
}

# Used internally, to wrap commands which need $SILENCE
#
__exec() {
  eval "$1 $SILENCE"
}
